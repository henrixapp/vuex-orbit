'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _store = require('@orbit/store');

var _store2 = _interopRequireDefault(_store);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class VuexStore extends _store2.default {
    constructor(settings = {}) {
        super(settings);
        this.namespaced = false;
        if (settings.schema) {
            //generate vuex store
            this.state = this.state || {};
            Object.keys(this._schema.models).forEach(type => {
                let model = settings.schema.getModel(type);
                this.state = this.state || {};
                //add to state
                //singularized
                this.state[type] = null;
                //and a collection
                this.state[`${type}Collection`] = [];
            });
            //map fields
            this.getters = {
                getField: state => {
                    return path => path.split(/[.[\]]+/).reduce((prev, key) => {
                        if (prev != null) {
                            return prev[key];
                        } else {
                            return null;
                        }
                    }, state);
                }
            };
            this.actions = {
                //TODO: Add fetch settings like json api
                create: ({ commit, dispatch }, record) => {
                    this.update(t => t.addRecord(record)).then(data => {
                        // dispatch("fetchAllOf", record.type);
                        commit("set", { data: record, model: record.type });
                        //TODO: relationships 
                    });
                },
                /**
                 * @argument model: The model as singularized name
                 */
                fetchAllOf: ({ commit }, model) => {
                    this.query(q => q.findRecords(model)).then(data => {
                        commit('set', { data, model: `${model}Collection` });
                    });
                },
                fetchAllRelatedOf: ({ commit }, query) => {
                    this.query(q => q.findRelatedRecords(query.data, query.relationship)).then(data => {
                        commit('set', { data, model: query.relationship }); //mind that this is the pluralized version
                    });
                },
                fetchRelatedOf: ({ commit }, query) => {
                    this.query(q => q.findRelatedRecord(query.data, query.relationship)).then(data => {
                        commit('set', { data, model: query.relationship }); //singularized version
                    });
                },
                fetchOne: ({ commit }, { model, id }) => {
                    this.query(q => q.findRecord({ type: model, id })).then(data => commit('set', { data, model: model }));
                },
                update: ({ commit }, data) => {
                    this.update(t => t.updateRecord(data)).then(() => commit('set', { data, model: data.type }));
                },
                delete: ({ commit, dispatch }, data) => {
                    this.update(t => t.removeRecord(data)).then(() => {
                        //update
                        dispatch("fetchAllOf", data.type);
                    });
                },
                updating: (store, options) => {
                    this.update(options.transformOrOperations).then(data => {
                        options.thenable(store, data);
                    });
                },
                querying: (store, options) => {
                    this.query(q => {
                        return options.queryOrExpression(q);
                    }).then(data => {
                        options.thenable(store, data);
                    });
                }
                //TODO: RelatedRecords update and delete
            };
            this.mutations = {
                remove: (state, { data, model }) => {
                    if (model.lastIndexOf('s') !== model.length - 1) {
                        let index = state[model + 's'].findIndex(record => record.id == data.id);
                        state[model + 's'].splice(index, 1);
                    } else {
                        let index = state[model + 's'].findIndex(record => record.id == data.id);
                        state[model + 's'].splice(index, 1);
                    }
                },
                set: (state, { data, model }) => {
                    state[model] = data;
                    if (model.endsWith("Collection")) {
                        //update also in Collection
                        let setted = false;
                        state[`${model}Collection`].forEach(item => {
                            if (item.id === data.id) {
                                item.attributes = data.attributes;
                                item.relationships = data.relationships;
                                item.keys = data.keys;
                                setted = true;
                            }
                        });
                        if (!setted) {
                            state[this.schema.pluralize(model)].push(data);
                        }
                    } else {
                        //splice data in oder to achieve updates
                        state[model] = [];
                        state[model] = data;
                        state[model].splice(data.length);
                    }
                },
                updateField: (state, { path, value }) => {
                    //set in field
                    path.split(/[.[\]]+/).reduce((prev, key, index, array) => {
                        if (array.length === index + 1) {
                            // eslint-disable-next-line no-param-reassign
                            prev[key] = value;
                        }
                        return prev[key];
                    }, state);
                }
            };
        }
    }
}
exports.default = VuexStore;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInZ1ZXgtc3RvcmUuanMiXSwibmFtZXMiOlsiVnVleFN0b3JlIiwiU3RvcmUiLCJjb25zdHJ1Y3RvciIsInNldHRpbmdzIiwibmFtZXNwYWNlZCIsInNjaGVtYSIsInN0YXRlIiwiT2JqZWN0Iiwia2V5cyIsIl9zY2hlbWEiLCJtb2RlbHMiLCJmb3JFYWNoIiwidHlwZSIsIm1vZGVsIiwiZ2V0TW9kZWwiLCJnZXR0ZXJzIiwiZ2V0RmllbGQiLCJwYXRoIiwic3BsaXQiLCJyZWR1Y2UiLCJwcmV2Iiwia2V5IiwiYWN0aW9ucyIsImNyZWF0ZSIsImNvbW1pdCIsImRpc3BhdGNoIiwicmVjb3JkIiwidXBkYXRlIiwidCIsImFkZFJlY29yZCIsInRoZW4iLCJkYXRhIiwiZmV0Y2hBbGxPZiIsInF1ZXJ5IiwicSIsImZpbmRSZWNvcmRzIiwiZmV0Y2hBbGxSZWxhdGVkT2YiLCJmaW5kUmVsYXRlZFJlY29yZHMiLCJyZWxhdGlvbnNoaXAiLCJmZXRjaFJlbGF0ZWRPZiIsImZpbmRSZWxhdGVkUmVjb3JkIiwiZmV0Y2hPbmUiLCJpZCIsImZpbmRSZWNvcmQiLCJ1cGRhdGVSZWNvcmQiLCJkZWxldGUiLCJyZW1vdmVSZWNvcmQiLCJ1cGRhdGluZyIsInN0b3JlIiwib3B0aW9ucyIsInRyYW5zZm9ybU9yT3BlcmF0aW9ucyIsInRoZW5hYmxlIiwicXVlcnlpbmciLCJxdWVyeU9yRXhwcmVzc2lvbiIsIm11dGF0aW9ucyIsInJlbW92ZSIsImxhc3RJbmRleE9mIiwibGVuZ3RoIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJzZXQiLCJlbmRzV2l0aCIsInNldHRlZCIsIml0ZW0iLCJhdHRyaWJ1dGVzIiwicmVsYXRpb25zaGlwcyIsInBsdXJhbGl6ZSIsInB1c2giLCJ1cGRhdGVGaWVsZCIsInZhbHVlIiwiYXJyYXkiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7QUFDZSxNQUFNQSxTQUFOLFNBQXdCQyxlQUF4QixDQUE4QjtBQUN6Q0MsZ0JBQVlDLFdB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QXJCLEVBQXlCO0FBQ3JCc0IscUNBQUtDLFVBQUwsR0FBa0JsQyxLQUFLa0MsVUFBdkI7QUFDQUQscUNBQUtFLGFBQUwsR0FBcUJuQyxLQUFLbUMsYUFBMUI7QUFDQUYscUNBQUt4RCxJQUFMLEdBQVl1QixLQUFLdkIsSUFBakI7QUFDQXVELHlDQUFTLElBQVQ7QUFDSDtBQUNKLHlCQVBEO0FBUUEsNEJBQUksQ0FBQ0EsTUFBTCxFQUFhO0FBQ1R6RCxrQ0FBTSxLQUFLRCxNQUFMLENBQVk4RCxTQUFaLENBQXNCdEQsS0FBdEIsQ0FBTixFQUFvQ3VELElBQXBDLENBQXlDckMsSUFBekM7QUFDSDtBQUNKLHFCQWRELE1BY087QUFDSDtBQUNBekIsOEJBQU1PLEtBQU4sSUFBZSxFQUFmO0FBQ0FQLDhCQUFNTyxLQUFOLElBQWVrQixJQUFmO0FBQ0F6Qiw4QkFBTU8sS0FBTixFQUFhK0MsTUFBYixDQUFvQjdCLEtBQUswQixNQUF6QjtBQUNIO0FBQ0osaUJBaENZO0FBaUNiWSw2QkFBYSxDQUFDL0QsS0FBRCxFQUFRLEVBQUVXLElBQUYsRUFBUXFELEtBQVIsRUFBUixLQUE0QjtBQUNyQztBQUNBckQseUJBQUtDLEtBQUwsQ0FBVyxTQUFYLEVBQXNCQyxNQUF0QixDQUE2QixDQUFDQyxJQUFELEVBQU9DLEdBQVAsRUFBWXFDLEtBQVosRUFBbUJhLEtBQW5CLEtBQTZCO0FBQ3RELDRCQUFJQSxNQUFNZCxNQUFOLEtBQWlCQyxRQUFRLENBQTdCLEVBQWdDO0FBQzVCO0FBQ0F0QyxpQ0FBS0MsR0FBTCxJQUFZaUQsS0FBWjtBQUNIO0FBQ0QsK0JBQU9sRCxLQUFLQyxHQUFMLENBQVA7QUFDSCxxQkFORCxFQU1HZixLQU5IO0FBT0g7QUExQ1ksYUFBakI7QUE0Q0g7QUFDSjtBQTlId0M7a0JBQXhCTixTIiwiZmlsZSI6InZ1ZXgtc3RvcmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3RvcmUgZnJvbSAnQG9yYml0L3N0b3JlJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZ1ZXhTdG9yZSBleHRlbmRzIFN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChzZXR0aW5ncy5zY2hlbWEpIHtcbiAgICAgICAgICAgIC8vZ2VuZXJhdGUgdnVleCBzdG9yZVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGUgfHwge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9zY2hlbWEubW9kZWxzKS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBtb2RlbCA9IHNldHRpbmdzLnNjaGVtYS5nZXRNb2RlbCh0eXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZSB8fCB7fTtcbiAgICAgICAgICAgICAgICAvL2FkZCB0byBzdGF0ZVxuICAgICAgICAgICAgICAgIC8vc2luZ3VsYXJpemVkXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVt0eXBlXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy9hbmQgYSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVtgJHt0eXBlfUNvbGxlY3Rpb25gXSA9IFtdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvL21hcCBmaWVsZHNcbiAgICAgICAgICAgIHRoaXMuZ2V0dGVycyA9IHtcbiAgICAgICAgICAgICAgICBnZXRGaWVsZDogc3RhdGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aCA9PiBwYXRoLnNwbGl0KC9bLltcXF1dKy8pLnJlZHVjZSgocHJldiwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zID0ge1xuICAgICAgICAgICAgICAgIC8vVE9ETzogQWRkIGZldGNoIHNldHRpbmdzIGxpa2UganNvbiBhcGlcbiAgICAgICAgICAgICAgICBjcmVhdGU6ICh7IGNvbW1pdCwgZGlzcGF0Y2ggfSwgcmVjb3JkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHQgPT4gdC5hZGRSZWNvcmQocmVjb3JkKSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc3BhdGNoKFwiZmV0Y2hBbGxPZlwiLCByZWNvcmQudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21taXQoXCJzZXRcIiwgeyBkYXRhOiByZWNvcmQsIG1vZGVsOiByZWNvcmQudHlwZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETzogcmVsYXRpb25zaGlwcyBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAYXJndW1lbnQgbW9kZWw6IFRoZSBtb2RlbCBhcyBzaW5ndWxhcml6ZWQgbmFtZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZldGNoQWxsT2Y6ICh7IGNvbW1pdCB9LCBtb2RlbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5KHEgPT4gcS5maW5kUmVjb3Jkcyhtb2RlbCkpLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21taXQoJ3NldCcsIHsgZGF0YSwgbW9kZWw6IGAke21vZGVsfUNvbGxlY3Rpb25gIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZldGNoQWxsUmVsYXRlZE9mOiAoeyBjb21taXQgfSwgcXVlcnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeShxID0+IHEuZmluZFJlbGF0ZWRSZWNvcmRzKHF1ZXJ5LmRhdGEsIHF1ZXJ5LnJlbGF0aW9uc2hpcCkpLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21taXQoJ3NldCcsIHsgZGF0YSwgbW9kZWw6IHF1ZXJ5LnJlbGF0aW9uc2hpcCB9KTsgLy9taW5kIHRoYXQgdGhpcyBpcyB0aGUgcGx1cmFsaXplZCB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmV0Y2hSZWxhdGVkT2Y6ICh7IGNvbW1pdCB9LCBxdWVyeSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5KHEgPT4gcS5maW5kUmVsYXRlZFJlY29yZChxdWVyeS5kYXRhLCBxdWVyeS5yZWxhdGlvbnNoaXApKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0KCdzZXQnLCB7IGRhdGEsIG1vZGVsOiBxdWVyeS5yZWxhdGlvbnNoaXAgfSk7IC8vc2luZ3VsYXJpemVkIHZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmZXRjaE9uZTogKHsgY29tbWl0IH0sIHsgbW9kZWwsIGlkIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeShxID0+IHEuZmluZFJlY29yZCh7IHR5cGU6IG1vZGVsLCBpZCB9KSkudGhlbihkYXRhID0+IGNvbW1pdCgnc2V0JywgeyBkYXRhLCBtb2RlbDogbW9kZWwgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdXBkYXRlOiAoeyBjb21taXQgfSwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh0ID0+IHQudXBkYXRlUmVjb3JkKGRhdGEpKS50aGVuKCgpID0+IGNvbW1pdCgnc2V0JywgeyBkYXRhLCBtb2RlbDogZGF0YS50eXBlIH0pKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlbGV0ZTogKHsgY29tbWl0LCBkaXNwYXRjaCB9LCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHQgPT4gdC5yZW1vdmVSZWNvcmQoZGF0YSkpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy91cGRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKFwiZmV0Y2hBbGxPZlwiLCBkYXRhLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVwZGF0aW5nOiAoc3RvcmUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUob3B0aW9ucy50cmFuc2Zvcm1Pck9wZXJhdGlvbnMpLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRoZW5hYmxlKHN0b3JlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBxdWVyeWluZzogKHN0b3JlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnkocSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5xdWVyeU9yRXhwcmVzc2lvbihxKTtcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudGhlbmFibGUoc3RvcmUsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9UT0RPOiBSZWxhdGVkUmVjb3JkcyB1cGRhdGUgYW5kIGRlbGV0ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zID0ge1xuICAgICAgICAgICAgICAgIHJlbW92ZTogKHN0YXRlLCB7IGRhdGEsIG1vZGVsIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmxhc3RJbmRleE9mKCdzJykgIT09IG1vZGVsLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IHN0YXRlW21vZGVsICsgJ3MnXS5maW5kSW5kZXgocmVjb3JkID0+IHJlY29yZC5pZCA9PSBkYXRhLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlW21vZGVsICsgJ3MnXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gc3RhdGVbbW9kZWwgKyAncyddLmZpbmRJbmRleChyZWNvcmQgPT4gcmVjb3JkLmlkID09IGRhdGEuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVbbW9kZWwgKyAncyddLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogKHN0YXRlLCB7IGRhdGEsIG1vZGVsIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVbbW9kZWxdID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmVuZHNXaXRoKFwiQ29sbGVjdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy91cGRhdGUgYWxzbyBpbiBDb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2V0dGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVtgJHttb2RlbH1Db2xsZWN0aW9uYF0uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5pZCA9PT0gZGF0YS5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHJpYnV0ZXMgPSBkYXRhLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucmVsYXRpb25zaGlwcyA9IGRhdGEucmVsYXRpb25zaGlwcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5rZXlzID0gZGF0YS5rZXlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVt0aGlzLnNjaGVtYS5wbHVyYWxpemUobW9kZWwpXS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9zcGxpY2UgZGF0YSBpbiBvZGVyIHRvIGFjaGlldmUgdXBkYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVbbW9kZWxdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVttb2RlbF0gPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVbbW9kZWxdLnNwbGljZShkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVwZGF0ZUZpZWxkOiAoc3RhdGUsIHsgcGF0aCwgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvL3NldCBpbiBmaWVsZFxuICAgICAgICAgICAgICAgICAgICBwYXRoLnNwbGl0KC9bLltcXF1dKy8pLnJlZHVjZSgocHJldiwga2V5LCBpbmRleCwgYXJyYXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPT09IGluZGV4ICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSwgc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59Il19